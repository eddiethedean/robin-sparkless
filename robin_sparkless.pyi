"""
Type stubs for robin_sparkless (PySpark-like DataFrame API on Polars).
Use for static type checking (mypy, pyright, etc.).
"""

from __future__ import annotations

from datetime import date, datetime
from typing import Any, Union, overload

# Column arithmetic accepts Column or scalar (int, float, bool, str, None)
_ColumnOperand = Union["Column", int, float, bool, str, None]

# --- Classes ---

class SparkSession:
    @classmethod
    def builder(cls) -> SparkSessionBuilder: ...
    def is_case_sensitive(self) -> bool: ...
    def create_dataframe(
        self,
        data: Any,
        column_names: list[str],
    ) -> DataFrame: ...
    def createDataFrame(
        self,
        data: Any,
        column_names: list[str],
    ) -> DataFrame: ...
    def _create_dataframe_from_rows(
        self,
        data: Any,
        schema: list[tuple[str, str]],
    ) -> DataFrame: ...
    def read(self) -> DataFrameReader: ...
    def read_csv(self, path: str) -> DataFrame: ...
    def read_parquet(self, path: str) -> DataFrame: ...
    def read_json(self, path: str) -> DataFrame: ...
    def read_delta(
        self, path: str
    ) -> DataFrame: ...  # path or table name (temp view then saved table)
    def read_delta_version(
        self, path: str, version: int | None = None
    ) -> DataFrame: ...  # path or table name; version ignored for in-memory tables
    def create_or_replace_temp_view(self, name: str, df: DataFrame) -> None: ...
    def table(self, name: str) -> DataFrame: ...
    def sql(self, query: str) -> DataFrame: ...
    def catalog(self) -> Catalog: ...
    def conf(self) -> RuntimeConfig: ...
    def newSession(self) -> SparkSession: ...
    def stop(self) -> None: ...
    def range(self, start: int, end: int | None = None, step: int = 1) -> DataFrame: ...
    def version(self) -> str: ...
    def udf(self) -> UDFRegistration: ...
    @classmethod
    def get_active_session(cls) -> SparkSession | None: ...
    @classmethod
    def get_default_session(cls) -> SparkSession | None: ...

class Catalog:
    def dropTempView(self, view_name: str) -> None: ...
    def dropGlobalTempView(self, view_name: str) -> bool: ...
    def dropTable(self, table_name: str) -> bool: ...  # in-memory saved tables only
    def listTables(self, db_name: str | None = None) -> list[str]: ...
    def tableExists(self, table_name: str, db_name: str | None = None) -> bool: ...
    def currentDatabase(self) -> str: ...
    def currentCatalog(self) -> str: ...
    def listDatabases(self, pattern: str | None = None) -> list[str]: ...
    def listCatalogs(self, pattern: str | None = None) -> list[str]: ...
    def cacheTable(self, table_name: str, storage_level: Any = None) -> None: ...
    def uncacheTable(self, table_name: str) -> None: ...
    def clearCache(self) -> None: ...
    def refreshTable(self, table_name: str) -> None: ...
    def refreshByPath(self, path: str) -> None: ...
    def recoverPartitions(self, table_name: str) -> None: ...
    def createTable(self, table_name: str) -> None: ...  # raises NotImplementedError
    def createExternalTable(
        self, table_name: str
    ) -> None: ...  # raises NotImplementedError
    def getDatabase(self, db_name: str) -> None: ...  # raises NotImplementedError
    def getFunction(self, function_name: str) -> None: ...  # raises NotImplementedError
    def getTable(self, table_name: str) -> None: ...  # raises NotImplementedError
    def databaseExists(self, db_name: str) -> bool: ...
    def functionExists(
        self, function_name: str, db_name: str | None = None
    ) -> bool: ...
    def setCurrentCatalog(self, catalog_name: str) -> None: ...
    def setCurrentDatabase(self, db_name: str) -> None: ...
    def registerFunction(
        self, name: str, f: Any, return_type: Any = None
    ) -> None: ...  # raises NotImplementedError
    def isCached(self, table_name: str) -> bool: ...
    def listColumns(self, table_name: str, db_name: str | None = None) -> list[str]: ...
    def listFunctions(
        self, db_name: str | None = None, pattern: str | None = None
    ) -> list[str]: ...

class RuntimeConfig:
    def get(self, key: str) -> str: ...
    def set(self, key: str, value: str) -> None: ...  # raises NotImplementedError
    def getAll(self) -> dict[str, str]: ...
    def isModifiable(self, key: str) -> bool: ...

class UDFRegistration:
    def register(
        self,
        name: str,
        f: Any,
        return_type: Any | None = None,
        vectorized: bool = False,
    ) -> UserDefinedFunction: ...

class UserDefinedFunction:
    def __call__(self, *cols: Column | str) -> Column: ...

class DataFrameReader:
    def option(self, key: str, value: str) -> DataFrameReader: ...
    def options(self, **kwargs: str) -> DataFrameReader: ...
    def format(self, fmt: str) -> DataFrameReader: ...
    def schema(self, schema: Any) -> DataFrameReader: ...
    def load(self, path: str) -> DataFrame: ...
    def table(self, name: str) -> DataFrame: ...
    def csv(self, path: str) -> DataFrame: ...
    def parquet(self, path: str) -> DataFrame: ...
    def json(self, path: str) -> DataFrame: ...

class SparkSessionBuilder:
    def app_name(self, name: str) -> SparkSessionBuilder: ...
    def master(self, master: str) -> SparkSessionBuilder: ...
    def config(self, key: str, value: str) -> SparkSessionBuilder: ...
    def get_or_create(self) -> SparkSession: ...

class DataFrame:
    def count(self) -> int: ...
    def show(self, n: int | None = None) -> None: ...
    def collect(self) -> list[dict[str, Any]]: ...
    def filter(self, condition: Column | bool) -> DataFrame: ...
    def select(self, *cols: str | Column | list[str] | list[Column]) -> DataFrame: ...
    def select_expr(self, exprs: list[str]) -> DataFrame: ...
    def with_column(self, column_name: str, expr: _ColumnOperand) -> DataFrame: ...
    def with_columns(
        self, mapping: dict[str, Column] | list[tuple[str, Column]]
    ) -> DataFrame: ...
    def with_columns_renamed(
        self,
        mapping: dict[str, str] | list[tuple[str, str]],
    ) -> DataFrame: ...
    def with_column_renamed(self, old: str, new: str) -> DataFrame: ...
    def order_by(
        self,
        cols: list[str] | SortOrder | list[SortOrder],
        ascending: list[bool] | None = None,
    ) -> DataFrame: ...
    def order_by_exprs(self, sort_orders: list[SortOrder]) -> DataFrame: ...
    def group_by(self, cols: list[str]) -> GroupedData: ...
    def agg(
        self, exprs: Column | list[Column] | tuple[Column, ...]
    ) -> DataFrame: ...  # global aggregation (no groupBy), single-row result
    def limit(self, n: int) -> DataFrame: ...
    def distinct(self, subset: list[str] | None = None) -> DataFrame: ...
    def union(self, other: DataFrame) -> DataFrame: ...
    def union_by_name(self, other: DataFrame) -> DataFrame: ...
    def join(
        self,
        other: DataFrame,
        on: str | list[str] | tuple[str, ...],
        how: str = "inner",
    ) -> DataFrame: ...
    def drop(self, cols: list[str]) -> DataFrame: ...
    def dropna(
        self,
        subset: list[str] | None = None,
        how: str = "any",
        thresh: int | None = None,
    ) -> DataFrame: ...
    def fillna(
        self,
        value: Union[int, float, bool, str, Column],
        subset: list[str] | None = None,
    ) -> DataFrame: ...
    def replace(
        self,
        to_replace: int | float | bool | str | None,
        value: int | float | bool | str | None,
        subset: list[str] | None = None,
    ) -> DataFrame: ...
    def pivot(self, pivot_col: str, values: list[str] | None = None) -> DataFrame: ...
    def col_regex(self, pattern: str) -> DataFrame: ...
    def stat(self) -> DataFrameStat: ...
    def na(self) -> DataFrameNa: ...
    def to_pandas(self) -> list[dict[str, Any]]: ...
    def toPandas(self) -> list[dict[str, Any]]: ...
    def to_df(self, names: list[str]) -> DataFrame: ...
    def toDF(self, names: list[str]) -> DataFrame: ...
    def to_json(self) -> list[str]: ...
    def toJSON(self) -> list[str]: ...
    def corr(
        self, col1: str | None = None, col2: str | None = None
    ) -> DataFrame | float: ...
    def cov(self, col1: str, col2: str) -> float: ...
    def write(self) -> DataFrameWriter: ...
    def writeTo(self) -> None: ...  # raises NotImplementedError
    def write_delta_table(self, name: str) -> None: ...  # in-memory table by name
    def createOrReplaceTempView(self, name: str) -> None: ...
    def createTempView(self, name: str) -> None: ...
    def createGlobalTempView(self, name: str) -> None: ...
    def createOrReplaceGlobalTempView(self, name: str) -> None: ...
    def hint(self, name: str, params: list[int]) -> DataFrame: ...
    def repartitionByRange(self, num_partitions: int, *cols: str) -> DataFrame: ...
    def sortWithinPartitions(self, *cols: str) -> DataFrame: ...
    def sameSemantics(self, other: DataFrame) -> bool: ...
    def semanticHash(self) -> int: ...
    def columns(self) -> list[str]: ...
    def cache(self) -> DataFrame: ...
    def isLocal(self) -> bool: ...
    def inputFiles(self) -> list[str]: ...

class DataFrameStat:
    def cov(self, col1: str, col2: str) -> float: ...
    def corr(self, col1: str, col2: str) -> float: ...
    def corr_matrix(self) -> DataFrame: ...

class DataFrameNa:
    def fill(
        self,
        value: Union[int, float, bool, str, Column],
        subset: list[str] | None = None,
    ) -> DataFrame: ...
    def drop(
        self,
        subset: list[str] | None = None,
        how: str = "any",
        thresh: int | None = None,
    ) -> DataFrame: ...

class Column:
    def alias(self, name: str) -> Column: ...
    def isin(self, values: list[int] | list[str]) -> Column: ...
    def asc(self) -> SortOrder: ...
    def asc_nulls_first(self) -> SortOrder: ...
    def asc_nulls_last(self) -> SortOrder: ...
    def desc(self) -> SortOrder: ...
    def desc_nulls_first(self) -> SortOrder: ...
    def desc_nulls_last(self) -> SortOrder: ...
    def gt(self, other: _ColumnOperand) -> Column: ...
    def ge(self, other: _ColumnOperand) -> Column: ...
    def lt(self, other: _ColumnOperand) -> Column: ...
    def le(self, other: _ColumnOperand) -> Column: ...
    def eq(self, other: _ColumnOperand) -> Column: ...
    def neq(self, other: _ColumnOperand) -> Column: ...
    def eq_null_safe(self, other: _ColumnOperand) -> Column: ...
    def between(self, low: _ColumnOperand, high: _ColumnOperand) -> Column: ...
    def __eq__(self, other: object) -> Column: ...  # type: ignore[override]
    def __ne__(self, other: object) -> Column: ...  # type: ignore[override]
    def __lt__(self, other: _ColumnOperand) -> Column: ...
    def __le__(self, other: _ColumnOperand) -> Column: ...
    def __gt__(self, other: _ColumnOperand) -> Column: ...
    def __ge__(self, other: _ColumnOperand) -> Column: ...
    def __add__(self, other: _ColumnOperand) -> Column: ...
    def __radd__(self, other: int | float | bool | str | None) -> Column: ...
    def __sub__(self, other: _ColumnOperand) -> Column: ...
    def __rsub__(self, other: int | float | bool | str | None) -> Column: ...
    def __mul__(self, other: _ColumnOperand) -> Column: ...
    def __rmul__(self, other: int | float | bool | str | None) -> Column: ...
    def multiply(self, other: Column) -> Column: ...
    def __truediv__(self, other: _ColumnOperand) -> Column: ...
    def __rtruediv__(self, other: int | float | bool | str | None) -> Column: ...
    def __mod__(self, other: _ColumnOperand) -> Column: ...
    def __rmod__(self, other: int | float | bool | str | None) -> Column: ...
    def __and__(self, other: Column) -> Column: ...
    def __or__(self, other: Column) -> Column: ...
    def and_(self, other: Column) -> Column: ...
    def or_(self, other: Column) -> Column: ...
    def map_concat(self, other: Column) -> Column: ...
    def year(self) -> Column: ...
    def month(self) -> Column: ...
    def nullif(self, other: Column) -> Column: ...
    def cast(self, type_name: str) -> Column: ...
    def try_cast(self, type_name: str) -> Column: ...
    def astype(self, type_name: str) -> Column: ...
    def split(self, delimiter: str, limit: int | None = None) -> Column: ...
    def substr(self, start: int, length: int | None = None) -> Column: ...
    def length(self) -> Column: ...
    def trim(self) -> Column: ...
    def ltrim(self) -> Column: ...
    def rtrim(self) -> Column: ...
    def repeat(self, n: int) -> Column: ...
    def reverse(self) -> Column: ...
    def initcap(self) -> Column: ...
    def regexp_extract(self, pattern: str, idx: int = 0) -> Column: ...
    def regexp_replace(self, pattern: str, replacement: str) -> Column: ...
    def floor(self) -> Column: ...
    def round(self, scale: int = 0) -> Column: ...
    def exp(self) -> Column: ...
    def levenshtein(self, other: Column) -> Column: ...
    def crc32(self) -> Column: ...
    def xxhash64(self) -> Column: ...
    def lower(self) -> Column: ...
    def upper(self) -> Column: ...
    def array_repeat(self, n: int) -> Column: ...
    def explode(self) -> Column: ...
    def posexplode(self) -> tuple[Column, Column]: ...
    def get_json_object(self, path: str) -> Column: ...
    def json_tuple(self, keys: list[str]) -> Column: ...
    def from_csv(self) -> Column: ...
    def to_csv(self) -> Column: ...
    def schema_of_csv(self) -> Column: ...
    def schema_of_json(self) -> Column: ...
    # Window API (#187): use with .over(partition_by)
    def over(self, partition_by: list[str]) -> Column: ...
    def row_number(self, descending: bool = False) -> Column: ...
    def rank(self, descending: bool = False) -> Column: ...
    def dense_rank(self, descending: bool = False) -> Column: ...
    def lag(self, n: int = 1) -> Column: ...
    def lead(self, n: int = 1) -> Column: ...
    def first_value(self) -> Column: ...
    def last_value(self) -> Column: ...
    def percent_rank(
        self, partition_by: list[str], descending: bool = False
    ) -> Column: ...
    def cume_dist(
        self, partition_by: list[str], descending: bool = False
    ) -> Column: ...
    def ntile(
        self, n: int, partition_by: list[str], descending: bool = False
    ) -> Column: ...
    def nth_value(
        self, n: int, partition_by: list[str], descending: bool = False
    ) -> Column: ...

class SortOrder: ...

class WhenThen:
    """Result of when(condition, value). Call .otherwise(default) to get a Column (PySpark parity)."""

    def otherwise(self, value: Column) -> Column: ...

class WhenBuilder:
    """Result of when(condition). Chain .then(value).otherwise(default)."""

    def then(self, value: Column) -> ThenBuilder: ...

class ThenBuilder:
    def otherwise(self, value: Column) -> Column: ...

class GroupedData:
    def count(self) -> DataFrame: ...
    def sum(self, column: str) -> DataFrame: ...
    def avg(self, column: str) -> DataFrame: ...
    def min(self, column: str) -> DataFrame: ...
    def max(self, column: str) -> DataFrame: ...
    def agg(self, exprs: list[Column]) -> DataFrame: ...
    def collect_list(self, column: str) -> DataFrame: ...
    def collect_set(self, column: str) -> DataFrame: ...
    def count_if(self, column: str) -> DataFrame: ...
    def any_value(self, column: str) -> DataFrame: ...
    def bool_and(self, column: str) -> DataFrame: ...
    def bool_or(self, column: str) -> DataFrame: ...
    def product(self, column: str) -> DataFrame: ...
    def kurtosis(self, column: str) -> DataFrame: ...
    def skewness(self, column: str) -> DataFrame: ...

class CubeRollupData:
    def agg(self, exprs: list[Column]) -> DataFrame: ...

class Window:
    @classmethod
    def partitionBy(cls, *cols: Union[str, Column]) -> Window: ...
    def orderBy(self, *cols: Union[str, Column]) -> Window: ...

class RowNumber:
    def over(self, window: Window) -> Column: ...

class DataFrameWriter:
    def mode(self, mode: str) -> DataFrameWriter: ...
    def format(self, format: str) -> DataFrameWriter: ...
    def option(self, key: str, value: str) -> DataFrameWriter: ...
    def options(self, **kwargs: str) -> DataFrameWriter: ...
    def partition_by(self, *cols: str) -> DataFrameWriter: ...
    def parquet(self, path: str) -> None: ...
    def csv(self, path: str) -> None: ...
    def json(self, path: str) -> None: ...
    def save(self, path: str) -> None: ...
    def saveAsTable(
        self,
        name: str,
        format: str | None = None,
        mode: str | None = None,
        partition_by: Any = None,
        **options: str,
    ) -> None: ...  # in-memory; format/partitionBy/options ignored

# --- Module-level functions (expression builders return Column) ---

def col(name: str) -> Column: ...
def lit(value: None | int | float | bool | str | date | datetime) -> Column: ...
def call_udf(name: str, *cols: Column | str) -> Column: ...
def pandas_udf(
    f: Any,
    return_type: Any | None = None,
    *,
    function_type: str = "grouped_agg",
) -> UserDefinedFunction: ...
def row_number(descending: bool = False) -> RowNumber: ...
@overload
def when(condition: Column) -> WhenBuilder: ...
@overload
def when(condition: Column, value: Column) -> WhenThen: ...
def coalesce(*cols: Column) -> Column: ...
def sum(column: Column) -> Column: ...
def avg(column: Column) -> Column: ...
def mean(column: Column) -> Column: ...  # alias for avg
def min(column: Column) -> Column: ...
def max(column: Column) -> Column: ...
def count(column: Column) -> Column: ...
def _execute_plan(
    data: Any,
    schema: list[tuple[str, str]],
    plan_json: str,
) -> DataFrame: ...
def supported_plan_operations() -> tuple[str, ...]: ...
def _configure_for_multiprocessing() -> None: ...

# Unary column functions (column -> Column)
def ascii(column: Column) -> Column: ...
def base64(column: Column) -> Column: ...
def unbase64(column: Column) -> Column: ...
def cast(column: Column, dtype: str) -> Column: ...
def try_cast(column: Column, dtype: str) -> Column: ...
def isnull(column: Column) -> Column: ...
def isnotnull(column: Column) -> Column: ...
def isnan(column: Column) -> Column: ...
def asc(column: Column) -> SortOrder: ...
def asc_nulls_first(column: Column) -> SortOrder: ...
def asc_nulls_last(column: Column) -> SortOrder: ...
def desc(column: Column) -> SortOrder: ...
def desc_nulls_first(column: Column) -> SortOrder: ...
def desc_nulls_last(column: Column) -> SortOrder: ...

# Binary / variadic (common patterns; others follow same style)
def greatest(*columns: Column) -> Column: ...
def least(*columns: Column) -> Column: ...
def add_months(column: Column, n: int) -> Column: ...
def substring(column: Column, pos: int, len: int) -> Column: ...
def overlay(src: Column, replace: str, pos: int, len: int = -1) -> Column: ...
def format_number(column: Column, d: int) -> Column: ...
def format_string(fmt: str, *columns: Column) -> Column: ...
def concat(*columns: Column) -> Column: ...
def concat_ws(sep: str, *columns: Column) -> Column: ...
def array(*columns: Column) -> Column: ...
def struct(*columns: Column) -> Column: ...
def named_struct(names: list[str], columns: list[Column]) -> Column: ...
def create_map(*key_value_columns: Column) -> Column: ...
def map_concat(a: Column, b: Column) -> Column: ...
def equal_null(a: Column, b: Column) -> Column: ...
def get(column: Column, key: Any) -> Column: ...
def get_json_object(column: Column, path: str) -> Column: ...
def json_tuple(column: Column, keys: list[str]) -> Column: ...
def from_csv(column: Column) -> Column: ...
def to_csv(column: Column) -> Column: ...
def schema_of_csv(column: Column) -> Column: ...
def schema_of_json(column: Column) -> Column: ...
def isin(column: Column, values: Any) -> Column: ...
def rand(seed: int | None = None) -> Column: ...
def randn(seed: int | None = None) -> Column: ...

# Placeholder for remaining 200+ expression functions (same pattern: Column in, Column out)
def acos(column: Column) -> Column: ...
def acosh(column: Column) -> Column: ...
def asin(column: Column) -> Column: ...
def asinh(column: Column) -> Column: ...
def atan(column: Column) -> Column: ...
def atan2(y: Column, x: Column) -> Column: ...
def atanh(column: Column) -> Column: ...
def sin(column: Column) -> Column: ...
def cos(column: Column) -> Column: ...
def tan(column: Column) -> Column: ...
def sinh(column: Column) -> Column: ...
def cosh(column: Column) -> Column: ...
def tanh(column: Column) -> Column: ...
def degrees(column: Column) -> Column: ...
def radians(column: Column) -> Column: ...
def cbrt(column: Column) -> Column: ...
def abs(column: Column) -> Column: ...
def ceiling(column: Column) -> Column: ...
def ceil(column: Column) -> Column: ...  # alias for ceiling
def floor(column: Column) -> Column: ...
def exp(column: Column) -> Column: ...
def expm1(column: Column) -> Column: ...
def ln(column: Column) -> Column: ...
def log10(column: Column) -> Column: ...
def log1p(column: Column) -> Column: ...
def log2(column: Column) -> Column: ...
def power(base: Column, exp: Column) -> Column: ...
def rint(column: Column) -> Column: ...
def round(column: Column, scale: int = 0) -> Column: ...
def signum(column: Column) -> Column: ...
def sign(column: Column) -> Column: ...  # alias for signum
def sqrt(column: Column) -> Column: ...
def left(column: Column, n: int) -> Column: ...
def right(column: Column, n: int) -> Column: ...
def length(column: Column) -> Column: ...
def char_length(column: Column) -> Column: ...
def lower(column: Column) -> Column: ...
def upper(column: Column) -> Column: ...
def ltrim(column: Column) -> Column: ...
def rtrim(column: Column) -> Column: ...
def trim(column: Column) -> Column: ...
def btrim(column: Column, trim: str | None = None) -> Column: ...
def reverse(column: Column) -> Column: ...
def repeat(column: Column, n: int) -> Column: ...
def replace(src: Column, search: str, replacement: str) -> Column: ...
def contains(column: Column, literal: str) -> Column: ...
def startswith(column: Column, literal: str) -> Column: ...
def endswith(column: Column, literal: str) -> Column: ...
def position(substr: str, column: Column) -> Column: ...
def like(column: Column, pattern: str) -> Column: ...
def ilike(column: Column, pattern: str) -> Column: ...
def rlike(column: Column, pattern: str) -> Column: ...
def regexp_extract(column: Column, pattern: str, idx: int = 0) -> Column: ...
def regexp_replace(column: Column, pattern: str, replacement: str) -> Column: ...
def regexp_extract_all(column: Column, pattern: str, idx: int = 0) -> Column: ...
def split(column: Column, pattern: str, limit: int | None = None) -> Column: ...
def soundex(column: Column) -> Column: ...
def substring_index(column: Column, delim: str, count: int) -> Column: ...
def chr(column: Column) -> Column: ...
def char(column: Column) -> Column: ...
def md5(column: Column) -> Column: ...
def sha1(column: Column) -> Column: ...
def sha2(column: Column, numBits: int) -> Column: ...
def dayofmonth(column: Column) -> Column: ...
def dayofweek(column: Column) -> Column: ...
def dayofyear(column: Column) -> Column: ...
def year(column: Column) -> Column: ...
def month(column: Column) -> Column: ...
def nullif(col1: Column, col2: Column) -> Column: ...
def hour(column: Column) -> Column: ...
def minute(column: Column) -> Column: ...
def quarter(column: Column) -> Column: ...
def second(column: Column) -> Column: ...
def weekofyear(column: Column) -> Column: ...
def date_add(column: Column, days: int) -> Column: ...
def date_sub(column: Column, days: int) -> Column: ...
def datediff(end: Column, start: Column) -> Column: ...
def months_between(end: Column, start: Column) -> Column: ...
def to_date(column: Column) -> Column: ...
def to_timestamp(column: Column, format: str | None = None) -> Column: ...
def unix_timestamp(column: Column, fmt: str | None = None) -> Column: ...
def from_unixtime(column: Column, fmt: str = "yyyy-MM-dd HH:mm:ss") -> Column: ...
def current_timestamp() -> Column: ...
def current_date() -> Column: ...
def date_format(column: Column, fmt: str) -> Column: ...
def date_trunc(format: str, column: Column) -> Column: ...
def nvl(column: Column, replacement: Column) -> Column: ...
def nvl2(column: Column, if_not_null: Column, if_null: Column) -> Column: ...
def ifnull(column: Column, replacement: Column) -> Column: ...
def array_contains(column: Column, value: Any) -> Column: ...
def array_distinct(column: Column) -> Column: ...
def array_except(a: Column, b: Column) -> Column: ...
def array_intersect(a: Column, b: Column) -> Column: ...
def array_join(
    column: Column, delimiter: str, null_replacement: str | None = None
) -> Column: ...
def array_max(column: Column) -> Column: ...
def array_min(column: Column) -> Column: ...
def array_position(column: Column, value: Any) -> Column: ...
def array_remove(column: Column, value: Any) -> Column: ...
def array_sort(column: Column) -> Column: ...
def aggregate(column: Column, zero: Column) -> Column: ...
def array_union(a: Column, b: Column) -> Column: ...
def arrays_zip(*columns: Column) -> Column: ...
def explode(column: Column) -> Column: ...
def explode_outer(column: Column) -> Column: ...
def posexplode(column: Column | str) -> tuple[Column, Column]: ...
def size(column: Column) -> Column: ...
def array_size(column: Column) -> Column: ...
def cardinality(column: Column) -> Column: ...
def slice(column: Column, start: int, length: int) -> Column: ...
def sort_array(column: Column, asc: bool = True) -> Column: ...
def element_at(column: Column, idx: int) -> Column: ...
def map_keys(column: Column) -> Column: ...
def map_values(column: Column) -> Column: ...
def map_contains_key(column: Column, key: Any) -> Column: ...
def ntile(n: int) -> Column: ...
def broadcast(df: DataFrame) -> DataFrame: ...
def input_file_name() -> Column: ...
def monotonically_increasing_id() -> Column: ...
def spark_partition_id() -> Column: ...
def version() -> Column: ...
def current_user() -> Column: ...
def user() -> Column: ...
def hash(*columns: Column) -> Column: ...
def try_add(left: Column, right: Column) -> Column: ...
def crc32(column: Column) -> Column: ...
def xxhash64(column: Column) -> Column: ...
def initcap(column: Column) -> Column: ...
def levenshtein(col1: Column, col2: Column) -> Column: ...
def assert_true(column: Column) -> Column: ...
def raise_error(column: Column) -> Column: ...
def bitwiseNOT(column: Column) -> Column: ...
def bitwise_not(column: Column) -> Column: ...
def bit_count(column: Column) -> Column: ...
def bit_get(column: Column, bit: int) -> Column: ...
def getbit(column: Column, bit: int) -> Column: ...
def shiftleft(column: Column, n: int) -> Column: ...
def shiftright(column: Column, n: int) -> Column: ...
def shift_left(column: Column, n: int) -> Column: ...
def shift_right(column: Column, n: int) -> Column: ...
def typeof(column: Column) -> Column: ...
def bround(column: Column, scale: int = 0) -> Column: ...
def negate(column: Column) -> Column: ...
def positive(column: Column) -> Column: ...
def cot(column: Column) -> Column: ...
def csc(column: Column) -> Column: ...
def sec(column: Column) -> Column: ...
def e() -> Column: ...
def pi() -> Column: ...
def median(column: Column) -> Column: ...
def mode(column: Column) -> Column: ...
def std(column: Column) -> Column: ...  # alias for stddev
def stddev(column: Column) -> Column: ...
def stddev_pop(column: Column) -> Column: ...
def var_pop(column: Column) -> Column: ...
def count_distinct(column: Column) -> Column: ...
def approx_count_distinct(column: Column) -> Column: ...
def first(column: Column) -> Column: ...
def last(column: Column) -> Column: ...
def collect_list(column: Column) -> Column: ...
def collect_set(column: Column) -> Column: ...
